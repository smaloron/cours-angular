<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2025-08-19T13:46:13.067192"><title>Module 8 : Pour aller plus loin - La Puissance des Op&eacute;rateurs RxJS | Angular</title><script type="application/json" id="virtual-toc-data">[{"id":"objectifs-p-dagogiques","level":0,"title":"Objectifs pédagogiques","anchor":"#objectifs-p-dagogiques"},{"id":"introduction-la-cha-ne-de-montage-de-vos-donn-es","level":0,"title":"Introduction : La Chaîne de Montage de vos Données","anchor":"#introduction-la-cha-ne-de-montage-de-vos-donn-es"},{"id":"1-le-pipeline-pipe","level":0,"title":"1. Le Pipeline : .pipe()","anchor":"#1-le-pipeline-pipe"},{"id":"2-op-rateurs-de-transformation-et-de-filtrage","level":0,"title":"2. Opérateurs de Transformation et de Filtrage","anchor":"#2-op-rateurs-de-transformation-et-de-filtrage"},{"id":"3-gestion-des-erreurs-avec-catcherror","level":0,"title":"3. Gestion des Erreurs avec catchError","anchor":"#3-gestion-des-erreurs-avec-catcherror"},{"id":"4-map-vs-switchmap-l-op-rateur-d-aplatissement-cl","level":0,"title":"4. map vs switchMap : L\u0027Opérateur d\u0027Aplatissement Clé","anchor":"#4-map-vs-switchmap-l-op-rateur-d-aplatissement-cl"},{"id":"exercice-pratique","level":0,"title":"Exercice pratique","anchor":"#exercice-pratique"},{"id":"auto-valuation","level":0,"title":"Auto-évaluation","anchor":"#auto-valuation"},{"id":"conclusion-de-ce-chapitre","level":0,"title":"Conclusion de ce chapitre","anchor":"#conclusion-de-ce-chapitre"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Module 8 : Pour aller plus loin - La Puissance des Op&eacute;rateurs RxJS | Angular"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Angular Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/008-01-rxjs-operators.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Module 8 : Pour aller plus loin - La Puissance des Op&eacute;rateurs RxJS | Angular"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/008-01-rxjs-operators.html#webpage",
    "url": "writerside-documentation/008-01-rxjs-operators.html",
    "name": "Module 8 : Pour aller plus loin - La Puissance des Op&eacute;rateurs RxJS | Angular",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Angular Help"
}</script><!-- End Schema.org --></head><body data-id="008-01-rxjs-operators" data-main-title="Module 8 : Pour aller plus loin - La Puissance des Opérateurs RxJS" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="008-00-httpclient.md|Module 8 : L'essentiel - Communication avec le Backend : HttpClient et RxJS"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Angular  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="008-01-rxjs-operators" id="008-01-rxjs-operators.md">Module 8 : Pour aller plus loin - La Puissance des Opérateurs RxJS</h1><section class="chapter"><h2 id="objectifs-p-dagogiques" data-toc="objectifs-p-dagogiques">Objectifs p&eacute;dagogiques</h2><p id="-jas6hf_12">&Agrave; la fin de cette partie, vous serez en mesure de :</p><ul class="list _bullet" id="-jas6hf_13"><li class="list__item" id="-jas6hf_14"><p id="-jas6hf_19"><span class="control" id="-jas6hf_20">Utiliser</span> la m&eacute;thode <code class="code" id="-jas6hf_21">.pipe()</code> pour encha&icirc;ner des op&eacute;rateurs RxJS.</p></li><li class="list__item" id="-jas6hf_15"><p id="-jas6hf_22"><span class="control" id="-jas6hf_23">Transformer</span> les donn&eacute;es d'un flux avec l'op&eacute;rateur <code class="code" id="-jas6hf_24">map</code>.</p></li><li class="list__item" id="-jas6hf_16"><p id="-jas6hf_25"><span class="control" id="-jas6hf_26">Filtrer</span> les donn&eacute;es d'un flux avec l'op&eacute;rateur <code class="code" id="-jas6hf_27">filter</code>.</p></li><li class="list__item" id="-jas6hf_17"><p id="-jas6hf_28"><span class="control" id="-jas6hf_29">G&eacute;rer</span> les erreurs HTTP de mani&egrave;re centralis&eacute;e avec l'op&eacute;rateur <code class="code" id="-jas6hf_30">catchError</code>.</p></li><li class="list__item" id="-jas6hf_18"><p id="-jas6hf_31"><span class="control" id="-jas6hf_32">Comprendre</span> la diff&eacute;rence fondamentale entre <code class="code" id="-jas6hf_33">map</code> et <code class="code" id="-jas6hf_34">switchMap</code> pour g&eacute;rer les appels HTTP d&eacute;pendants.</p></li></ul></section><section class="chapter"><h2 id="introduction-la-cha-ne-de-montage-de-vos-donn-es" data-toc="introduction-la-cha-ne-de-montage-de-vos-donn-es">Introduction : La Cha&icirc;ne de Montage de vos Donn&eacute;es</h2><p id="-jas6hf_35">Dans la partie &quot;L'essentiel&quot;, nous avons r&eacute;cup&eacute;r&eacute; des donn&eacute;es brutes de l'API et tout le traitement se faisait dans le <code class="code" id="-jas6hf_39">.subscribe()</code> de notre composant. C'est fonctionnel, mais cela peut vite devenir complexe et charger le composant de responsabilit&eacute;s qui ne sont pas les siennes.</p><p id="-jas6hf_36">Imaginez une cha&icirc;ne de montage dans une usine. Les mati&egrave;res premi&egrave;res (la r&eacute;ponse de l'API) arrivent d'un c&ocirc;t&eacute;. Au lieu de tout faire &agrave; la fin de la cha&icirc;ne, on place des &quot;op&eacute;rateurs&quot; sp&eacute;cialis&eacute;s tout le long :</p><ol class="list _decimal" id="-jas6hf_37" type="1"><li class="list__item" id="-jas6hf_40"><p id="-jas6hf_43">Un premier poste <span class="control" id="-jas6hf_44">filtre</span> les pi&egrave;ces d&eacute;fectueuses.</p></li><li class="list__item" id="-jas6hf_41"><p id="-jas6hf_45">Un deuxi&egrave;me poste <span class="control" id="-jas6hf_46">transforme</span> chaque pi&egrave;ce (la peint en rouge, par exemple).</p></li><li class="list__item" id="-jas6hf_42"><p id="-jas6hf_47">Un troisi&egrave;me poste <span class="control" id="-jas6hf_48">ajoute</span> un &eacute;l&eacute;ment &agrave; chaque pi&egrave;ce.</p></li></ol><p id="-jas6hf_38">Les <span class="control" id="-jas6hf_49">op&eacute;rateurs RxJS</span> sont ces postes de travail. Ils vous permettent de construire un &quot;pipeline&quot; (<code class="code" id="-jas6hf_50">.pipe()</code>) pour traiter, transformer, filtrer et combiner vos flux de donn&eacute;es avant m&ecirc;me que le composant ne re&ccedil;oive le r&eacute;sultat final. Votre composant re&ccedil;oit alors des donn&eacute;es &quot;pr&ecirc;tes &agrave; l'emploi&quot;, ce qui le rend beaucoup plus simple et propre.</p></section><section class="chapter"><h2 id="1-le-pipeline-pipe" data-toc="1-le-pipeline-pipe">1. Le Pipeline : <code class="code" id="-jas6hf_54">.pipe()</code></h2><p id="-jas6hf_52">Tous les op&eacute;rateurs RxJS s'utilisent &agrave; l'int&eacute;rieur de la m&eacute;thode <code class="code" id="-jas6hf_55">.pipe()</code> d'un Observable. Cette m&eacute;thode prend un nombre illimit&eacute; d'op&eacute;rateurs en arguments, qui seront appliqu&eacute;s dans l'ordre.</p><div class="code-block" data-lang="ts">
import {map, filter, tap} from 'rxjs/operators';

// ...
myObservable.pipe(
    filter(data =&gt;...), // D'abord on filtre
    map(data =&gt;...),    // Ensuite on transforme
    tap(data =&gt;...)     // Puis on observe
).subscribe(...);
</div></section><section class="chapter"><h2 id="2-op-rateurs-de-transformation-et-de-filtrage" data-toc="2-op-rateurs-de-transformation-et-de-filtrage">2. Op&eacute;rateurs de Transformation et de Filtrage</h2><section class="chapter"><h3 id="map-transformer-chaque-valeur-mise" data-toc="map-transformer-chaque-valeur-mise"><code class="code" id="-jas6hf_63">map</code>: Transformer chaque valeur &eacute;mise</h3><p id="-jas6hf_59">L'op&eacute;rateur <code class="code" id="-jas6hf_64">map</code> est probablement le plus utilis&eacute;. Il prend une valeur en entr&eacute;e et retourne une nouvelle valeur transform&eacute;e. C'est exactement comme le <code class="code" id="-jas6hf_65">.map()</code> des tableaux en JavaScript.</p><p id="-jas6hf_60"><span class="control" id="-jas6hf_66">Sc&eacute;nario :</span> L'API nous retourne une liste d'utilisateurs, mais nous ne voulons que leurs noms.</p><div class="code-block" data-lang="ts">
// Fichier: user.service.ts
import {map} from 'rxjs/operators';

public getUserNames(): Observable &lt; string[] &gt; {
    return this.http.get&lt;User[]&gt;(this.apiUrl).pipe(
        // map prend le tableau de User[] en entrée
        // et doit retourner un tableau de string[] en sortie.
        map(users =&gt; users.map(user =&gt; user.name))
    );
}
</div><p id="-jas6hf_62">Le composant qui s'abonne &agrave; <code class="code" id="-jas6hf_67">getUserNames()</code> recevra directement un tableau de cha&icirc;nes de caract&egrave;res. Il n'a m&ecirc;me pas besoin de conna&icirc;tre l'existence de l'objet <code class="code" id="-jas6hf_68">User</code>.</p></section><section class="chapter"><h3 id="filter-ne-laisser-passer-que-certaines-valeurs" data-toc="filter-ne-laisser-passer-que-certaines-valeurs"><code class="code" id="-jas6hf_74">filter</code>: Ne laisser passer que certaines valeurs</h3><p id="-jas6hf_70">L'op&eacute;rateur <code class="code" id="-jas6hf_75">filter</code> ne s'applique g&eacute;n&eacute;ralement pas directement aux appels HTTP (qui n'&eacute;mettent qu'une seule valeur, le tableau complet), mais il est fondamental dans RxJS. Il est tr&egrave;s utile pour des flux qui &eacute;mettent plusieurs valeurs ( comme des &eacute;v&eacute;nements de clic ou des WebSockets).</p><p id="-jas6hf_71">Pour filtrer les <span class="emphasis" id="-jas6hf_76">&eacute;l&eacute;ments d'un tableau</span> re&ccedil;u via HTTP, on combine <code class="code" id="-jas6hf_77">map</code> et le <code class="code" id="-jas6hf_78">.filter()</code> des tableaux.</p><p id="-jas6hf_72"><span class="control" id="-jas6hf_79">Sc&eacute;nario :</span> R&eacute;cup&eacute;rer uniquement les utilisateurs &quot;actifs&quot; d'une API (supposons qu'ils ont une propri&eacute;t&eacute; <code class="code" id="-jas6hf_80">isActive</code>).</p><div class="code-block" data-lang="ts">
// Fichier: user.service.ts
import {map} from 'rxjs/operators';

public getActiveUsers(): Observable &lt; User[] &gt; {
    return this.http.get&lt;User[]&gt;(this.apiUrl).pipe(
        // map prend le tableau de User[] en entrée
        // et retourne un NOUVEAU tableau de User[] filtré.
        map(users =&gt; users.filter(user =&gt; user.isActive)) // Supposons que User a une prop isActive
    );
}
</div></section></section><section class="chapter"><h2 id="3-gestion-des-erreurs-avec-catcherror" data-toc="3-gestion-des-erreurs-avec-catcherror">3. Gestion des Erreurs avec <code class="code" id="-jas6hf_86">catchError</code></h2><p id="-jas6hf_82">Que se passe-t-il si l'appel HTTP &eacute;choue ? Au lieu de g&eacute;rer l'erreur dans chaque <code class="code" id="-jas6hf_87">.subscribe()</code>, on peut l'intercepter directement dans le service avec <code class="code" id="-jas6hf_88">catchError</code>.</p><p id="-jas6hf_83">Cet op&eacute;rateur doit retourner un <span class="control" id="-jas6hf_89">nouvel Observable</span> qui servira de &quot;plan B&quot;. Souvent, on veut juste retourner un Observable qui &eacute;met une valeur par d&eacute;faut (comme un tableau vide) et loguer l'erreur.</p><div class="code-block" data-lang="ts">
// Fichier: user.service.ts
import {catchError, map} from 'rxjs/operators';
import {of} from 'rxjs'; // 'of' est une fonction qui crée un Observable à partir d'une valeur simple.

public getUsers(): Observable &lt; User[] &gt; {
    return this.http.get&lt;User[]&gt;(this.apiUrl).pipe(
        tap(users =&gt; console.log(`${users.length} utilisateurs reçus de l'API`)), // tap est utile pour les &quot;effets de bord&quot; comme le logging
        catchError(error =&gt; {
            console.error(&quot;Erreur interceptée dans le service :&quot;, error);
            // On retourne un Observable qui émet un tableau vide.
            // Le composant recevra un tableau vide au lieu d'une erreur.
            return of([]);
        })
    );
}
</div><p id="-jas6hf_85">Avec ce code, le canal <code class="code" id="-jas6hf_90">error</code> du <code class="code" id="-jas6hf_91">subscribe</code> ne sera jamais appel&eacute;. Le composant recevra simplement <code class="code" id="-jas6hf_92">[]</code>, ce qui est souvent plus simple &agrave; g&eacute;rer dans le template.</p></section><section class="chapter"><h2 id="4-map-vs-switchmap-l-op-rateur-d-aplatissement-cl" data-toc="4-map-vs-switchmap-l-op-rateur-d-aplatissement-cl">4. <code class="code" id="-jas6hf_102">map</code> vs <code class="code" id="-jas6hf_103">switchMap</code>: L'Op&eacute;rateur d'Aplatissement Cl&eacute;</h2><p id="-jas6hf_94">C'est un concept avanc&eacute; mais <span class="control" id="-jas6hf_104">absolument crucial</span>.</p><p id="-jas6hf_95"><span class="control" id="-jas6hf_105">Probl&egrave;me :</span> Vous avez des appels HTTP qui d&eacute;pendent les uns des autres.</p><ol class="list _decimal" id="-jas6hf_96" type="1"><li class="list__item" id="-jas6hf_106"><p id="-jas6hf_108">R&eacute;cup&eacute;rer les informations de l'utilisateur connect&eacute; (<code class="code" id="-jas6hf_109">/me</code>).</p></li><li class="list__item" id="-jas6hf_107"><p id="-jas6hf_110">Une fois qu'on a son ID, r&eacute;cup&eacute;rer ses commandes (<code class="code" id="-jas6hf_111">/users/{id}/orders</code>).</p></li></ol><p id="-jas6hf_97">Si on utilise <code class="code" id="-jas6hf_112">map</code>, on se retrouve avec un <code class="code" id="-jas6hf_113">Observable</code> dans un <code class="code" id="-jas6hf_114">Observable</code> (<code class="code" id="-jas6hf_115">Observable&lt;Observable&lt;Order[]&gt;&gt;</code>). C'est un cauchemar &agrave; g&eacute;rer.</p><div class="code-block" data-lang="ts">
// MAUVAISE approche avec map
getUserOrders_Bad(): Observable &lt; Observable &lt; Order[] &gt;&gt; {
    return this.http.get&lt;User&gt;('/me').pipe(
        map(user =&gt; this.http.get&lt;Order[]&gt;(`/users/${user.id}/orders`))
    );
}
</div><p id="-jas6hf_99"><span class="control" id="-jas6hf_116">Solution :</span> Les op&eacute;rateurs &quot;d'aplatissement&quot; comme <code class="code" id="-jas6hf_117">switchMap</code>. <code class="code" id="-jas6hf_118">switchMap</code> est con&ccedil;u pour ce sc&eacute;nario. Il prend la valeur du premier Observable (<code class="code" id="-jas6hf_119">user</code>), puis attend que vous retourniez un <span class="control" id="-jas6hf_120">nouvel Observable</span> (<code class="code" id="-jas6hf_121">http.get(...)</code>). Il va automatiquement &quot;s'abonner&quot; &agrave; ce nouvel Observable interne et vous retourner directement les valeurs de celui-ci.</p><div class="code-block" data-lang="ts">
// BONNE approche avec switchMap
import {switchMap} from 'rxjs/operators';

getUserOrders_Good(): Observable &lt; Order[] &gt; {
    return this.http.get&lt;User&gt;('/me').pipe(
        // user est l'objet User du premier appel
        // On doit retourner un NOUVEL observable
        switchMap(user =&gt; this.http.get&lt;Order[]&gt;(`/users/${user.id}/orders`))
    );
}
</div><p id="-jas6hf_101">Le composant qui s'abonne &agrave; <code class="code" id="-jas6hf_122">getUserOrders_Good()</code> recevra directement un <code class="code" id="-jas6hf_123">Order[]</code>. C'est simple et propre. <code class="code" id="-jas6hf_124">switchMap</code> est l'op&eacute;rateur de choix pour les appels HTTP encha&icirc;n&eacute;s.</p></section><section class="chapter"><h2 id="exercice-pratique" data-toc="exercice-pratique">Exercice pratique</h2><section class="chapter"><h3 id="exercice-2-afficher-les-posts-d-un-utilisateur-sp-cifique" data-toc="exercice-2-afficher-les-posts-d-un-utilisateur-sp-cifique">Exercice 2 : Afficher les Posts d'un Utilisateur Sp&eacute;cifique</h3><p id="-jas6hf_127">Votre mission est d'utiliser <code class="code" id="-jas6hf_129">switchMap</code> pour afficher uniquement les &quot;posts&quot; (articles) du premier utilisateur retourn&eacute; par l'API.</p><ol class="list _decimal" id="-jas6hf_128" type="1"><li class="list__item" id="-jas6hf_130"><p id="-jas6hf_135">Dans votre <code class="code" id="-jas6hf_136">UserService</code>, cr&eacute;ez une m&eacute;thode <code class="code" id="-jas6hf_137">getFirstUser()</code> qui retourne un <code class="code" id="-jas6hf_138">Observable&lt;User&gt;</code> (le premier utilisateur de la liste <code class="code" id="-jas6hf_139">/users</code>). Utilisez l'op&eacute;rateur <code class="code" id="-jas6hf_140">map</code> pour ne prendre que <code class="code" id="-jas6hf_141">users[0]</code>.</p></li><li class="list__item" id="-jas6hf_131"><p id="-jas6hf_142">Cr&eacute;ez un <code class="code" id="-jas6hf_143">PostService</code> avec une m&eacute;thode <code class="code" id="-jas6hf_144">getPostsForUser(userId: number)</code> qui retourne un <code class="code" id="-jas6hf_145">Observable&lt;Post[]&gt;</code> en appelant <code class="code" id="-jas6hf_146">https://jsonplaceholder.typicode.com/posts?userId={userId}</code>. (Cr&eacute;ez une interface <code class="code" id="-jas6hf_147">Post</code>: <code class="code" id="-jas6hf_148">id</code>, <code class="code" id="-jas6hf_149">userId</code>, <code class="code" id="-jas6hf_150">title</code>, <code class="code" id="-jas6hf_151">body</code>).</p></li><li class="list__item" id="-jas6hf_132"><p id="-jas6hf_152">Cr&eacute;ez un <code class="code" id="-jas6hf_153">UserPostsComponent</code>.</p></li><li class="list__item" id="-jas6hf_133"><p id="-jas6hf_154">Dans ce composant, injectez <code class="code" id="-jas6hf_155">UserService</code> et <code class="code" id="-jas6hf_156">PostService</code>.</p></li><li class="list__item" id="-jas6hf_134"><p id="-jas6hf_157">Dans <code class="code" id="-jas6hf_158">ngOnInit</code>, cha&icirc;nez les appels : a. Appelez <code class="code" id="-jas6hf_159">userService.getFirstUser()</code>. b. Utilisez <code class="code" id="-jas6hf_160">.pipe()</code> avec <code class="code" id="-jas6hf_161">switchMap</code> sur le r&eacute;sultat. c. &Agrave; l'int&eacute;rieur de <code class="code" id="-jas6hf_162">switchMap</code>, utilisez l'objet <code class="code" id="-jas6hf_163">user</code> re&ccedil;u pour appeler <code class="code" id="-jas6hf_164">postService.getPostsForUser(user.id)</code>. d. Abonnez-vous au r&eacute;sultat final pour afficher les posts.</p></li></ol></section><section class="chapter"><div class="collapse"><div class="collapse__title"><h3 id="correction-exercice-2" data-toc="correction-exercice-2">Correction exercice 2</h3></div><div class="collapse__content"><ol class="list _decimal" id="-jas6hf_165" type="1"><li class="list__item" id="-jas6hf_168"><p id="-jas6hf_169"><span class="control" id="-jas6hf_170"><code class="code" id="-jas6hf_171">user.service.ts</code> mis &agrave; jour :</span></p></li></ol><div class="code-block" data-lang="ts">
   import { map } from 'rxjs/operators';
   // ...
getFirstUser(): Observable&lt;User&gt; {
     return this.http.get&lt;User[]&gt;(this.apiUrl).pipe(
       map(users =&gt; users[0])
     );
}
</div><ol class="list _decimal" id="-jas6hf_167" type="1" start="2"><li class="list__item" id="-jas6hf_172"><p id="-jas6hf_174"><span class="control" id="-jas6hf_176"><code class="code" id="-jas6hf_177">post.service.ts</code>:</span></p><div class="code-block" data-lang="ts">
// Fichier: src/app/shared/services/post.service.ts
import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable } from 'rxjs';

export interface Post { id: number; userId: number; title: string; body: string; }

@Injectable({ providedIn: 'root' })
export class PostService {
  private apiUrl = 'https://jsonplaceholder.typicode.com/posts';
  constructor(private http: HttpClient) {}

  getPostsForUser(userId: number): Observable&lt;Post[]&gt; {
    return this.http.get&lt;Post[]&gt;(`${this.apiUrl}?userId=${userId}`);
  }
}
</div></li><li class="list__item" id="-jas6hf_173"><p id="-jas6hf_178">&amp; 4. &amp; 5. <span class="control" id="-jas6hf_180"><code class="code" id="-jas6hf_181">user-posts.component.ts</code>:</span></p><div class="code-block" data-lang="ts">
import { Component, OnInit } from '@angular/core';
import { switchMap } from 'rxjs/operators';
import { UserService } from '../../shared/services/user.service';
import { PostService, Post } from '../../shared/services/post.service';

@Component({ /* ... */ })
export class UserPostsComponent implements OnInit {
  public posts: Post[] = [];

  constructor(
    private userService: UserService,
    private postService: PostService
  ) {}

  ngOnInit(): void {
    this.userService.getFirstUser().pipe(
      switchMap(user =&gt; {
        if (!user) {
          // Gérer le cas où il n'y a pas d'utilisateur
          return []; // Retourne un observable vide
        }
        console.log(`Premier utilisateur trouvé : ${user.name}, ID: ${user.id}`);
        return this.postService.getPostsForUser(user.id);
      })
    ).subscribe(posts =&gt; {
      this.posts = posts;
      console.log(`Posts trouvés pour le premier utilisateur :`, posts);
    });
  }
}
</div></li></ol></div></div></section></section><section class="chapter"><h2 id="auto-valuation" data-toc="auto-valuation">Auto-&eacute;valuation</h2><p id="-jas6hf_183"><span class="control" id="-jas6hf_196">1. (Question ouverte)</span><br> &Agrave; quoi sert la m&eacute;thode <code class="code" id="-jas6hf_198">.pipe()</code> d'un Observable ?</p><p id="-jas6hf_185"><span class="control" id="-jas6hf_199">2. (QCM)</span><br> Quel op&eacute;rateur utiliseriez-vous pour transformer un <code class="code" id="-jas6hf_201">Observable&lt;User[]&gt;</code> en un <code class="code" id="-jas6hf_202">Observable&lt;number&gt;</code> qui &eacute;met uniquement le nombre total d'utilisateurs ?</p><ul class="list _bullet" id="-jas6hf_186"><li class="list__item" id="-jas6hf_203"><p id="-jas6hf_207">a) <code class="code" id="-jas6hf_208">filter</code></p></li><li class="list__item" id="-jas6hf_204"><p id="-jas6hf_209">b) <code class="code" id="-jas6hf_210">switchMap</code></p></li><li class="list__item" id="-jas6hf_205"><p id="-jas6hf_211">c) <code class="code" id="-jas6hf_212">map</code></p></li><li class="list__item" id="-jas6hf_206"><p id="-jas6hf_213">d) <code class="code" id="-jas6hf_214">catchError</code></p></li></ul><p id="-jas6hf_188"><span class="control" id="-jas6hf_215">3. (QCM)</span><br> Vous devez faire un premier appel pour r&eacute;cup&eacute;rer un <code class="code" id="-jas6hf_217">id</code> de cat&eacute;gorie, puis un second appel pour r&eacute;cup&eacute;rer les produits de cette cat&eacute;gorie. <br> Quel op&eacute;rateur est le plus adapt&eacute; pour encha&icirc;ner ces deux appels ?</p><ul class="list _bullet" id="-jas6hf_189"><li class="list__item" id="-jas6hf_219"><p id="-jas6hf_223">a) <code class="code" id="-jas6hf_224">map</code></p></li><li class="list__item" id="-jas6hf_220"><p id="-jas6hf_225">b) <code class="code" id="-jas6hf_226">tap</code></p></li><li class="list__item" id="-jas6hf_221"><p id="-jas6hf_227">c) <code class="code" id="-jas6hf_228">switchMap</code></p></li><li class="list__item" id="-jas6hf_222"><p id="-jas6hf_229">d) <code class="code" id="-jas6hf_230">merge</code></p></li></ul><p id="-jas6hf_191"><span class="control" id="-jas6hf_231">4. (Question ouverte)</span><br> Expliquez le r&ocirc;le de l'op&eacute;rateur <code class="code" id="-jas6hf_233">catchError</code>. <br> Que doit-il retourner pour que l'Observable ne se termine pas en erreur ?</p><p id="-jas6hf_193"><span class="control" id="-jas6hf_235">5. (QCM)</span><br> Quelle est la principale diff&eacute;rence de comportement entre <code class="code" id="-jas6hf_237">map</code> et <code class="code" id="-jas6hf_238">switchMap</code>?</p><ul class="list _bullet" id="-jas6hf_194"><li class="list__item" id="-jas6hf_239"><p id="-jas6hf_243">a) <code class="code" id="-jas6hf_244">map</code> transforme une valeur, tandis que <code class="code" id="-jas6hf_245">switchMap</code> filtre une valeur.</p></li><li class="list__item" id="-jas6hf_240"><p id="-jas6hf_246">b) <code class="code" id="-jas6hf_247">map</code> retourne une valeur simple, tandis que <code class="code" id="-jas6hf_248">switchMap</code> doit retourner un nouvel Observable.</p></li><li class="list__item" id="-jas6hf_241"><p id="-jas6hf_249">c) <code class="code" id="-jas6hf_250">switchMap</code> est plus rapide que <code class="code" id="-jas6hf_251">map</code>.</p></li><li class="list__item" id="-jas6hf_242"><p id="-jas6hf_252">d) <code class="code" id="-jas6hf_253">map</code> peut &ecirc;tre utilis&eacute; pour les erreurs, pas <code class="code" id="-jas6hf_254">switchMap</code>.</p></li></ul></section><section class="chapter"><h2 id="conclusion-de-ce-chapitre" data-toc="conclusion-de-ce-chapitre">Conclusion de ce chapitre</h2><p id="-jas6hf_255">Un immense bravo ! Vous venez de d&eacute;bloquer le v&eacute;ritable super-pouvoir d'Angular : la programmation r&eacute;active avec **RxJS * <span class="emphasis" id="-jas6hf_258">. Vous ne vous contentez plus de consommer des donn&eacute;es ; vous les orchestrez. Vous savez maintenant construire des * <span class="emphasis" id="-jas6hf_260">pipelines de traitement de donn&eacute;es</span></span> robustes et d&eacute;claratifs avec <code class="code" id="-jas6hf_259">.pipe()</code>, transformer, filtrer, et g&eacute;rer les erreurs de mani&egrave;re centralis&eacute;e.</p><p id="-jas6hf_256">Plus important encore, vous avez compris la puissance de <code class="code" id="-jas6hf_261">switchMap</code> pour g&eacute;rer les d&eacute;pendances asynchrones, un des sc&eacute;narios les plus courants et les plus complexes du d&eacute;veloppement web.</p><p id="-jas6hf_257">Cette connaissance des op&eacute;rateurs RxJS est ce qui distingue un d&eacute;veloppeur Angular d&eacute;butant d'un d&eacute;veloppeur exp&eacute;riment&eacute;. Vous &ecirc;tes maintenant pr&ecirc;t &agrave; aborder le dernier grand pilier d'une application : la gestion des entr&eacute;es utilisateur avec les <span class="control" id="-jas6hf_262">Formulaires R&eacute;actifs</span>.</p></section><div class="last-modified">16 août 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="008-00-httpclient.html" class="navigation-links__prev">Module 8 : L'essentiel - Communication avec le Backend : HttpClient et RxJS</a><a href="009-00-reactive-forms.html" class="navigation-links__next">Module 9 : L'essentiel - Les Formulaires R&eacute;actifs</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.js"></script></body></html>