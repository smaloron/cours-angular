<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2025-08-16T17:16:40.766803"><title>Module 10 : Pour aller plus loin - Op&eacute;rateurs de Combinaison et d'Aplatissement | Angular</title><script type="application/json" id="virtual-toc-data">[{"id":"objectifs-p-dagogiques","level":0,"title":"Objectifs pédagogiques","anchor":"#objectifs-p-dagogiques"},{"id":"introduction-g-rer-la-complexit-des-flux-asynchrones","level":0,"title":"Introduction : Gérer la complexité des flux asynchrones","anchor":"#introduction-g-rer-la-complexit-des-flux-asynchrones"},{"id":"1-le-probl-me-des-higher-order-observables","level":0,"title":"1. Le Problème des \"Higher-Order Observables\"","anchor":"#1-le-probl-me-des-higher-order-observables"},{"id":"2-les-op-rateurs-d-aplatissement","level":0,"title":"2. Les Opérateurs d\u0027Aplatissement","anchor":"#2-les-op-rateurs-d-aplatissement"},{"id":"3-op-rateurs-de-combinaison","level":0,"title":"3. Opérateurs de Combinaison","anchor":"#3-op-rateurs-de-combinaison"},{"id":"exercice-pratique","level":0,"title":"Exercice pratique","anchor":"#exercice-pratique"},{"id":"auto-valuation","level":0,"title":"Auto-évaluation","anchor":"#auto-valuation"},{"id":"conclusion-de-ce-chapitre","level":0,"title":"Conclusion de ce chapitre","anchor":"#conclusion-de-ce-chapitre"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Module 10 : Pour aller plus loin - Op&eacute;rateurs de Combinaison et d'Aplatissement | Angular"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Angular Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/010-01-advanced-rxjs.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Module 10 : Pour aller plus loin - Op&eacute;rateurs de Combinaison et d'Aplatissement | Angular"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/010-01-advanced-rxjs.html#webpage",
    "url": "writerside-documentation/010-01-advanced-rxjs.html",
    "name": "Module 10 : Pour aller plus loin - Op&eacute;rateurs de Combinaison et d'Aplatissement | Angular",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Angular Help"
}</script><!-- End Schema.org --></head><body data-id="010-01-advanced-rxjs" data-main-title="Module 10 : Pour aller plus loin - Opérateurs de Combinaison et d'Aplatissement" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="010-00-rxjs-streams.md|Module 10 : L'essentiel - RxJS, Penser en Flux de Données"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Angular  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="010-01-advanced-rxjs" id="010-01-advanced-rxjs.md">Module 10 : Pour aller plus loin - Opérateurs de Combinaison et d'Aplatissement</h1><section class="chapter"><h2 id="objectifs-p-dagogiques" data-toc="objectifs-p-dagogiques">Objectifs p&eacute;dagogiques</h2><p id="t70cnd_11">&Agrave; la fin de cette partie, vous serez en mesure de :</p><ul class="list _bullet" id="t70cnd_12"><li class="list__item" id="t70cnd_13"><p id="t70cnd_17"><span class="control" id="t70cnd_18">Comprendre</span> la probl&eacute;matique des &quot;Observables d'Observables&quot; et comment les &quot;aplatir&quot;.</p></li><li class="list__item" id="t70cnd_14"><p id="t70cnd_19"><span class="control" id="t70cnd_20">Ma&icirc;triser</span> l'op&eacute;rateur <code class="code" id="t70cnd_21">switchMap</code> pour g&eacute;rer les appels HTTP d&eacute;pendants, le cas d'usage le plus courant.</p></li><li class="list__item" id="t70cnd_15"><p id="t70cnd_22"><span class="control" id="t70cnd_23">Diff&eacute;rencier</span> les strat&eacute;gies d'aplatissement : <code class="code" id="t70cnd_24">switchMap</code>, <code class="code" id="t70cnd_25">mergeMap</code>, <code class="code" id="t70cnd_26">concatMap</code>, et <code class="code" id="t70cnd_27">exhaustMap</code>.</p></li><li class="list__item" id="t70cnd_16"><p id="t70cnd_28"><span class="control" id="t70cnd_29">Combiner</span> les r&eacute;sultats de plusieurs Observables ind&eacute;pendants en un seul flux avec <code class="code" id="t70cnd_30">forkJoin</code> et <code class="code" id="t70cnd_31">combineLatest</code>.</p></li></ul></section><section class="chapter"><h2 id="introduction-g-rer-la-complexit-des-flux-asynchrones" data-toc="introduction-g-rer-la-complexit-des-flux-asynchrones">Introduction : G&eacute;rer la complexit&eacute; des flux asynchrones</h2><p id="t70cnd_32">Dans le monde r&eacute;el, les flux de donn&eacute;es sont rarement simples et isol&eacute;s. Ils interagissent, d&eacute;pendent les uns des autres, ou doivent &ecirc;tre synchronis&eacute;s.</p><ul class="list _bullet" id="t70cnd_33"><li class="list__item" id="t70cnd_35"><p id="t70cnd_38">Comment faire un appel API, et seulement apr&egrave;s avoir re&ccedil;u la r&eacute;ponse, en faire un deuxi&egrave;me avec les donn&eacute;es du premier ?</p></li><li class="list__item" id="t70cnd_36"><p id="t70cnd_39">Comment lancer plusieurs appels API en parall&egrave;le et attendre que <span class="control" id="t70cnd_40">tous</span> soient termin&eacute;s avant d'agir ?</p></li><li class="list__item" id="t70cnd_37"><p id="t70cnd_41">Comment combiner les donn&eacute;es d'un formulaire qui change en temps r&eacute;el avec les r&eacute;sultats d'un appel API ?</p></li></ul><p id="t70cnd_34">Tenter de g&eacute;rer ces sc&eacute;narios avec des <code class="code" id="t70cnd_42">.subscribe()</code> imbriqu&eacute;s m&egrave;ne &agrave; un code illisible et difficile &agrave; maintenir, souvent appel&eacute; &quot;callback hell&quot;. Les op&eacute;rateurs d'aplatissement et de combinaison sont la solution de RxJS &agrave; ces probl&egrave;mes. Ils vous permettent de garder un code plat, lisible et d&eacute;claratif, m&ecirc;me pour les sc&eacute;narios asynchrones les plus complexes.</p></section><section class="chapter"><h2 id="1-le-probl-me-des-higher-order-observables" data-toc="1-le-probl-me-des-higher-order-observables">1. Le Probl&egrave;me des &quot;Higher-Order Observables&quot;</h2><p id="t70cnd_43">Un &quot;Higher-Order Observable&quot; est un Observable qui &eacute;met d'autres Observables. C'est ce qui se passe lorsque vous utilisez <code class="code" id="t70cnd_48">map</code> pour lancer un appel HTTP.</p><div class="code-block" data-lang="ts">
// MAUVAIS exemple : on se retrouve avec un Observable&lt;Observable&lt;Post[]&gt;&gt;
// C'est un &quot;Higher-Order Observable&quot;
getUserPosts()
:
Observable &lt; Observable &lt; Post[] &gt;&gt; {
    return this.http.get&lt;User&gt;('/api/user/1').pipe(
        map(user =&gt; this.http.get&lt;Post[]&gt;(`/api/posts?userId=${user.id}`))
    );
}
</div><p id="t70cnd_45">Pour utiliser le r&eacute;sultat, il faudrait s'abonner deux fois. C'est lourd et source d'erreurs.</p><div class="code-block" data-lang="ts">
// Surtout, ne faites pas ça !
this.userService.getUserPosts().subscribe(obsPosts =&gt; {
    obsPosts.subscribe(posts =&gt; {
        this.posts = posts;
    });
});
</div><p id="t70cnd_47">La solution est d' <span class="control" id="t70cnd_49">aplatir</span> ce flux : transformer <code class="code" id="t70cnd_50">Observable&lt;Observable&lt;T&gt;&gt;</code> en un simple <code class="code" id="t70cnd_51">Observable&lt;T&gt;</code>. C'est le r&ocirc;le des op&eacute;rateurs <code class="code" id="t70cnd_52">switchMap</code>, <code class="code" id="t70cnd_53">mergeMap</code>, etc.</p></section><section class="chapter"><h2 id="2-les-op-rateurs-d-aplatissement" data-toc="2-les-op-rateurs-d-aplatissement">2. Les Op&eacute;rateurs d'Aplatissement</h2><p id="t70cnd_54">Ces op&eacute;rateurs s'abonnent &agrave; l'Observable interne pour vous et vous renvoient directement ses valeurs. Ils ne diff&egrave;rent que par la mani&egrave;re dont ils g&egrave;rent les arriv&eacute;es multiples de l'Observable source.</p><section class="chapter"><h3 id="switchmap-la-strat-gie-d-annulation" data-toc="switchmap-la-strat-gie-d-annulation"><code class="code" id="t70cnd_63">switchMap</code>: La Strat&eacute;gie d'Annulation</h3><p id="t70cnd_60"><code class="code" id="t70cnd_64">switchMap</code> est le plus courant pour les requ&ecirc;tes d&eacute;clench&eacute;es par l'utilisateur (recherche, clic...).</p><ul class="list _bullet" id="t70cnd_61"><li class="list__item" id="t70cnd_65"><p id="t70cnd_68"><span class="control" id="t70cnd_69">Comportement :</span> D&egrave;s que l'Observable source &eacute;met une nouvelle valeur, <code class="code" id="t70cnd_70">switchMap</code> <span class="control" id="t70cnd_71">se d&eacute;sabonne de l'Observable interne pr&eacute;c&eacute;dent</span> et s'abonne au nouveau.</p></li><li class="list__item" id="t70cnd_66"><p id="t70cnd_72"><span class="control" id="t70cnd_73">Analogie :</span> Vous tapez &quot;a&quot;, une recherche est lanc&eacute;e. Vous tapez &quot;b&quot; 100ms plus tard. La recherche pour &quot;a&quot; est * <span class="emphasis" id="t70cnd_74">annul&eacute;e</span>*, et une nouvelle recherche pour &quot;ab&quot; est lanc&eacute;e.</p></li><li class="list__item" id="t70cnd_67"><p id="t70cnd_75"><span class="control" id="t70cnd_76">Cas d'usage :</span> Parfait pour les champs de recherche, les filtres... tout ce qui peut &ecirc;tre d&eacute;clench&eacute; rapidement et o&ugrave; seule la derni&egrave;re valeur compte.</p></li></ul><div class="code-block" data-lang="ts">
// Exemple parfait : un champ de recherche
searchControl.valueChanges.pipe(
    debounceTime(300),
    distinctUntilChanged(),
    // Si l'utilisateur tape une nouvelle valeur, la requête HTTP précédente est annulée.
    switchMap(term =&gt; this.api.search(term))
).subscribe(results =&gt;
...)
;
</div></section><section class="chapter"><h3 id="mergemap-ou-flatmap-la-strat-gie-parall-le" data-toc="mergemap-ou-flatmap-la-strat-gie-parall-le"><code class="code" id="t70cnd_80">mergeMap</code> (ou <code class="code" id="t70cnd_81">flatMap</code>) : La Strat&eacute;gie Parall&egrave;le</h3><p id="t70cnd_78"><code class="code" id="t70cnd_82">mergeMap</code> ne se soucie pas de l'ordre. Il s'abonne &agrave; tous les Observables internes et &eacute;met leurs valeurs d&egrave;s qu'elles arrivent.</p><ul class="list _bullet" id="t70cnd_79"><li class="list__item" id="t70cnd_83"><p id="t70cnd_86"><span class="control" id="t70cnd_87">Comportement :</span> Ex&eacute;cute tout en parall&egrave;le.</p></li><li class="list__item" id="t70cnd_84"><p id="t70cnd_88"><span class="control" id="t70cnd_89">Analogie :</span> Vous cliquez 3 fois sur un bouton &quot;Ajouter au panier&quot;. 3 requ&ecirc;tes partent en m&ecirc;me temps. Les r&eacute;ponses arrivent dans le d&eacute;sordre, mais elles arrivent toutes.</p></li><li class="list__item" id="t70cnd_85"><p id="t70cnd_90"><span class="control" id="t70cnd_91">Cas d'usage :</span> Utile pour des actions ind&eacute;pendantes que l'on veut ex&eacute;cuter sans attendre la pr&eacute;c&eacute;dente (ex: upload de plusieurs fichiers).</p></li></ul></section><section class="chapter"><h3 id="concatmap-la-strat-gie-s-quentielle-file-d-attente" data-toc="concatmap-la-strat-gie-s-quentielle-file-d-attente"><code class="code" id="t70cnd_95">concatMap</code>: La Strat&eacute;gie S&eacute;quentielle (File d'attente)</h3><p id="t70cnd_93"><code class="code" id="t70cnd_96">concatMap</code> attend que l'Observable interne pr&eacute;c&eacute;dent soit compl&eacute;t&eacute; avant de s'abonner au suivant.</p><ul class="list _bullet" id="t70cnd_94"><li class="list__item" id="t70cnd_97"><p id="t70cnd_100"><span class="control" id="t70cnd_101">Comportement :</span> Traite les &eacute;missions une par une, dans l'ordre.</p></li><li class="list__item" id="t70cnd_98"><p id="t70cnd_102"><span class="control" id="t70cnd_103">Analogie :</span> Vous cliquez 3 fois pour sauvegarder. La 2&egrave;me sauvegarde ne sera lanc&eacute;e <span class="control" id="t70cnd_104">qu'apr&egrave;s</span> la fin de la 1&egrave;re. La 3&egrave;me apr&egrave;s la fin de la 2&egrave;me.</p></li><li class="list__item" id="t70cnd_99"><p id="t70cnd_105"><span class="control" id="t70cnd_106">Cas d'usage :</span> Crucial pour les op&eacute;rations de type <code class="code" id="t70cnd_107">POST</code>, <code class="code" id="t70cnd_108">PUT</code>, <code class="code" id="t70cnd_109">DELETE</code> o&ugrave; l'ordre est important et o&ugrave; l'on veut &eacute;viter les &quot;race conditions&quot;.</p></li></ul></section><section class="chapter"><h3 id="exhaustmap-la-strat-gie-ignorer" data-toc="exhaustmap-la-strat-gie-ignorer"><code class="code" id="t70cnd_113">exhaustMap</code>: La Strat&eacute;gie &quot;Ignorer&quot;</h3><p id="t70cnd_111"><code class="code" id="t70cnd_114">exhaustMap</code> ignore les nouvelles &eacute;missions de la source tant que son Observable interne n'est pas compl&eacute;t&eacute;.</p><ul class="list _bullet" id="t70cnd_112"><li class="list__item" id="t70cnd_115"><p id="t70cnd_118"><span class="control" id="t70cnd_119">Comportement :</span> Ignore les nouvelles demandes tant que la pr&eacute;c&eacute;dente est en cours.</p></li><li class="list__item" id="t70cnd_116"><p id="t70cnd_120"><span class="control" id="t70cnd_121">Analogie :</span> Vous cliquez sur un bouton &quot;Login&quot;. La requ&ecirc;te part. Vous re-cliquez fr&eacute;n&eacute;tiquement. Tous les clics suppl&eacute;mentaires sont <span class="control" id="t70cnd_122">ignor&eacute;s</span> jusqu'&agrave; ce que la premi&egrave;re requ&ecirc;te de login soit termin&eacute;e.</p></li><li class="list__item" id="t70cnd_117"><p id="t70cnd_123"><span class="control" id="t70cnd_124">Cas d'usage :</span> Parfait pour les boutons de soumission de formulaire pour &eacute;viter les double-clics.</p></li></ul></section></section><section class="chapter"><h2 id="3-op-rateurs-de-combinaison" data-toc="3-op-rateurs-de-combinaison">3. Op&eacute;rateurs de Combinaison</h2><p id="t70cnd_125">Ces op&eacute;rateurs permettent de g&eacute;rer plusieurs Observables ind&eacute;pendants.</p><section class="chapter"><h3 id="forkjoin-attendre-que-tout-soit-fini" data-toc="forkjoin-attendre-que-tout-soit-fini"><code class="code" id="t70cnd_132">forkJoin</code>: Attendre que tout soit fini</h3><p id="t70cnd_129"><code class="code" id="t70cnd_133">forkJoin</code> est l'&eacute;quivalent RxJS de <code class="code" id="t70cnd_134">Promise.all</code>. Il prend un tableau d'Observables, attend que <span class="control" id="t70cnd_135">tous</span> se compl&egrave;tent, puis &eacute;met une seule valeur : un tableau contenant la derni&egrave;re valeur de chaque Observable.</p><p id="t70cnd_130"><span class="control" id="t70cnd_136">Sc&eacute;nario :</span> Pour afficher une page, j'ai besoin des d&eacute;tails de l'utilisateur ET de la liste des cat&eacute;gories.</p><div class="code-block" data-lang="ts">
import {forkJoin} from 'rxjs';

const userDetails$ = this.http.get&lt;User&gt;('/api/user/1');
const categories$ = this.http.get&lt;Category[]&gt;('/api/categories');

forkJoin([userDetails$, categories$]).subscribe(
    ([user, categories]) =&gt; {
        // Ce code ne s'exécute que lorsque les DEUX appels sont terminés.
        console.log('Utilisateur:', user);
        console.log('Catégories:', categories);
        this.user = user;
        this.categories = categories;
    }
);
</div></section><section class="chapter"><h3 id="combinelatest-la-combinaison-en-temps-r-el" data-toc="combinelatest-la-combinaison-en-temps-r-el"><code class="code" id="t70cnd_141">combineLatest</code>: La combinaison en temps r&eacute;el</h3><p id="t70cnd_138"><code class="code" id="t70cnd_142">combineLatest</code> est diff&eacute;rent. Il &eacute;met une valeur d&egrave;s que <span class="control" id="t70cnd_143">tous</span> les Observables ont &eacute;mis au moins une fois. Ensuite, il &eacute;met une nouvelle valeur <span class="control" id="t70cnd_144">&agrave; chaque fois que l'un des Observables source &eacute;met</span>.</p><p id="t70cnd_139"><span class="control" id="t70cnd_145">Sc&eacute;nario :</span> Afficher une liste de produits filtr&eacute;e. Les filtres (<code class="code" id="t70cnd_146">Observable</code> venant d'un formulaire) et la liste de produits (<code class="code" id="t70cnd_147">Observable</code> venant d'un appel HTTP) sont combin&eacute;s.</p><div class="code-block" data-lang="ts">
import {combineLatest} from 'rxjs';

// Observable des produits (n'émet qu'une fois)
const products$ = this.productService.getProducts();

// Observable des filtres (émet à chaque changement du formulaire)
const filters$ = this.filterForm.valueChanges;

combineLatest([products$, filters$]).pipe(
    map(([products, filters]) =&gt; {
        // Cette fonction est ré-exécutée à chaque changement de filtre
        return products.filter(p =&gt; p.category === filters.category);
    })
).subscribe(filteredProducts =&gt; this.displayProducts(filteredProducts));
</div></section></section><section class="chapter"><h2 id="exercice-pratique" data-toc="exercice-pratique">Exercice pratique</h2><section class="chapter"><h3 id="exercice-2-tableau-de-bord-agr-g" data-toc="exercice-2-tableau-de-bord-agr-g">Exercice 2 : Tableau de bord agr&eacute;g&eacute;</h3><p id="t70cnd_150">Cr&eacute;ez un composant &quot;Dashboard&quot; qui a besoin de plusieurs informations pour s'afficher.</p><ol class="list _decimal" id="t70cnd_151" type="1"><li class="list__item" id="t70cnd_152"><p id="t70cnd_158">Dans votre <code class="code" id="t70cnd_159">UserService</code>, cr&eacute;ez une m&eacute;thode <code class="code" id="t70cnd_160">getLoggedInUser()</code> qui retourne les d&eacute;tails d'un utilisateur (simulez avec <code class="code" id="t70cnd_161">http.get('.../users/1')</code>).</p></li><li class="list__item" id="t70cnd_153"><p id="t70cnd_162">Dans votre <code class="code" id="t70cnd_163">PostService</code>, cr&eacute;ez une m&eacute;thode <code class="code" id="t70cnd_164">getLatestPosts()</code> qui retourne les 5 derniers posts (simulez avec <code class="code" id="t70cnd_165">http.get('.../posts?_limit=5')</code>).</p></li><li class="list__item" id="t70cnd_154"><p id="t70cnd_166">Dans votre <code class="code" id="t70cnd_167">CommentService</code>, cr&eacute;ez <code class="code" id="t70cnd_168">getLatestComments()</code> (simulez avec <code class="code" id="t70cnd_169">http.get('.../comments?_limit=5')</code>).</p></li><li class="list__item" id="t70cnd_155"><p id="t70cnd_170">Dans votre <code class="code" id="t70cnd_171">DashboardComponent</code>, utilisez <code class="code" id="t70cnd_172">forkJoin</code> pour lancer ces trois appels en parall&egrave;le.</p></li><li class="list__item" id="t70cnd_156"><p id="t70cnd_173">Lorsque tous les appels sont termin&eacute;s, stockez les r&eacute;sultats dans des propri&eacute;t&eacute;s s&eacute;par&eacute;es (<code class="code" id="t70cnd_174">user</code>, <code class="code" id="t70cnd_175">posts</code>, <code class="code" id="t70cnd_176">comments</code>).</p></li><li class="list__item" id="t70cnd_157"><p id="t70cnd_177">Utilisez le pipe <code class="code" id="t70cnd_178">async</code> et <code class="code" id="t70cnd_179">@if...as</code> dans votre template pour afficher un message de chargement, puis les donn&eacute;es une fois qu'elles sont toutes arriv&eacute;es.</p></li></ol></section><section class="chapter"><div class="collapse"><div class="collapse__title"><h3 id="correction-exercice-2" data-toc="correction-exercice-2">Correction exercice 2</h3></div><div class="collapse__content"><ol class="list _decimal" id="t70cnd_180" type="1"><li class="list__item" id="t70cnd_186"><p id="t70cnd_187">&agrave; 3. <span class="control" id="t70cnd_188">Services :</span> Les m&eacute;thodes dans les services respectifs retourneront simplement les appels HTTP. Exemple pour <code class="code" id="t70cnd_189">UserService</code>:</p></li></ol><div class="code-block" data-lang="ts">
public
getLoggedInUser()
:
Observable &lt; User &gt; {
    return this.http.get&lt;User&gt;(`${this.apiUrl}/1`);
}
</div><p id="t70cnd_182">(Idem pour les autres services)</p><ol class="list _decimal" id="t70cnd_183" type="1" start="4"><li class="list__item" id="t70cnd_190"><p id="t70cnd_191">&agrave; 6. <span class="control" id="t70cnd_192"><code class="code" id="t70cnd_193">dashboard.component.ts</code> et <code class="code" id="t70cnd_194">.html</code></span></p></li></ol><div class="code-block" data-lang="ts">
import {Component} from '@angular/core';
import {forkJoin, Observable} from 'rxjs';
import {map} from 'rxjs/operators';
// ... import des services et modèles

// Un modèle pour le résultat combiné
interface DashboardData {
    user: User;
    posts: Post[];
    comments: Comment[];
}

@Component({ /* ... */})
export class DashboardComponent {
    public data$: Observable&lt;DashboardData&gt;;

    constructor(
        private userService: UserService,
        private postService: PostService,
        private commentService: CommentService
    ) {
        // On lance les appels avec forkJoin
        this.data$ = forkJoin({
            user: this.userService.getLoggedInUser(),
            posts: this.postService.getLatestPosts(),
            comments: this.commentService.getLatestComments()
        });
        // forkJoin peut aussi prendre un objet, c'est plus lisible !
    }
}
</div><div class="code-block" data-lang="markup">
&lt;!-- dashboard.component.html --&gt;
&lt;h1&gt;Tableau de Bord&lt;/h1&gt;

@if (data$ | async; as data) {
&lt;section&gt;
    &lt;h2&gt;Bienvenue, {{ data.user.name }} !&lt;/h2&gt;
&lt;/section&gt;
&lt;section&gt;
    &lt;h3&gt;Derniers Posts&lt;/h3&gt;
    &lt;ul&gt;
        @for(post of data.posts; track post.id) {
        &lt;li&gt;{{post.title}}&lt;/li&gt;
        }
    &lt;/ul&gt;
&lt;/section&gt;
&lt;section&gt;
    &lt;h3&gt;Derniers Commentaires&lt;/h3&gt;
    &lt;ul&gt;
        @for(comment of data.comments; track comment.id) {
        &lt;li&gt;{{comment.name}}&lt;/li&gt;
        }
    &lt;/ul&gt;
&lt;/section&gt;
} @else {
&lt;p&gt;Chargement du tableau de bord...&lt;/p&gt;
}
</div></div></div></section></section><section class="chapter"><h2 id="auto-valuation" data-toc="auto-valuation">Auto-&eacute;valuation</h2><p id="t70cnd_196"><span class="control" id="t70cnd_205">1. (Question ouverte)</span><br> Expliquez la diff&eacute;rence de comportement fondamentale entre <code class="code" id="t70cnd_207">switchMap</code> et <code class="code" id="t70cnd_208">concatMap</code>. <br> Donnez un cas d'usage pour chacun.</p><p id="t70cnd_198"><span class="control" id="t70cnd_210">2. (QCM)</span><br> Vous voulez ex&eacute;cuter deux appels <code class="code" id="t70cnd_212">GET</code> en parall&egrave;le et ne continuer que lorsque les deux sont termin&eacute;s. <br> Quel op&eacute;rateur utiliser ?</p><ul class="list _bullet" id="t70cnd_199"><li class="list__item" id="t70cnd_214"><p id="t70cnd_218">a) <code class="code" id="t70cnd_219">combineLatest</code></p></li><li class="list__item" id="t70cnd_215"><p id="t70cnd_220">b) <code class="code" id="t70cnd_221">mergeMap</code></p></li><li class="list__item" id="t70cnd_216"><p id="t70cnd_222">c) <code class="code" id="t70cnd_223">forkJoin</code></p></li><li class="list__item" id="t70cnd_217"><p id="t70cnd_224">d) <code class="code" id="t70cnd_225">zip</code></p></li></ul><p id="t70cnd_201"><span class="control" id="t70cnd_226">3. (QCM)</span><br> Dans une barre de recherche, pour &eacute;viter de lancer une requ&ecirc;te HTTP &agrave; chaque frappe de l'utilisateur, <br> quelle combinaison d'op&eacute;rateurs est la plus pertinente ?</p><ul class="list _bullet" id="t70cnd_202"><li class="list__item" id="t70cnd_229"><p id="t70cnd_233">a) <code class="code" id="t70cnd_234">tap</code> et <code class="code" id="t70cnd_235">map</code></p></li><li class="list__item" id="t70cnd_230"><p id="t70cnd_236">b) <code class="code" id="t70cnd_237">debounceTime</code> et <code class="code" id="t70cnd_238">switchMap</code></p></li><li class="list__item" id="t70cnd_231"><p id="t70cnd_239">c) <code class="code" id="t70cnd_240">delay</code> et <code class="code" id="t70cnd_241">concatMap</code></p></li><li class="list__item" id="t70cnd_232"><p id="t70cnd_242">d) <code class="code" id="t70cnd_243">filter</code> et <code class="code" id="t70cnd_244">mergeMap</code></p></li></ul><p id="t70cnd_204"><span class="control" id="t70cnd_245">4. (Question ouverte)</span><br> Qu'est-ce qu'un &quot;Higher-Order Observable&quot; et quel est le r&ocirc;le des op&eacute;rateurs d'aplatissement (<code class="code" id="t70cnd_247">switchMap</code>, <code class="code" id="t70cnd_248">mergeMap</code>...) par rapport</p></section><section class="chapter"><h2 id="conclusion-de-ce-chapitre" data-toc="conclusion-de-ce-chapitre">Conclusion de ce chapitre</h2><p id="t70cnd_249">F&eacute;licitations ! Vous avez explor&eacute; les aspects les plus puissants et les plus utiles de RxJS. Vous &ecirc;tes maintenant capable de g&eacute;rer des sc&eacute;narios asynchrones complexes qui sont le quotidien des applications web modernes.</p><p id="t70cnd_250">Vous savez comment <span class="control" id="t70cnd_253">encha&icirc;ner des appels d&eacute;pendants</span> avec <code class="code" id="t70cnd_254">switchMap</code>, comment <span class="control" id="t70cnd_255">parall&eacute;liser et synchroniser</span> des appels avec <code class="code" id="t70cnd_256">forkJoin</code>, et comment choisir la bonne <span class="control" id="t70cnd_257">strat&eacute;gie d'aplatissement</span> en fonction du contexte.</p><p id="t70cnd_251">Cette connaissance approfondie de RxJS ne vous servira pas seulement dans Angular, mais dans tout l'&eacute;cosyst&egrave;me JavaScript moderne. C'est une comp&eacute;tence fondamentale qui vous place &agrave; un niveau de d&eacute;veloppeur senior.</p><p id="t70cnd_252">Nous avons maintenant couvert l'essentiel du framework. Le dernier module abordera des sujets compl&eacute;mentaires mais importants, comme le cycle de vie des composants et le build de production, pour finaliser votre parcours.</p></section><div class="last-modified">16 août 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="010-00-rxjs-streams.html" class="navigation-links__prev">Module 10 : L'essentiel - RxJS, Penser en Flux de Donn&eacute;es</a><a href="011-00-good-practices.html" class="navigation-links__next">Module 11 : L'essentiel - Sujets Compl&eacute;mentaires et Bonnes Pratiques</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.js"></script></body></html>